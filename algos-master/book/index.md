---
title: Practical Algorithms and Data Structures
layout: default.html
---

This book is a practical‚Äîand, we hope, entertaining‚Äîintroduction to some of the most important algorithms and data structures in computer science.

We know that some software engineers think ‚Äúpractical algorithms‚Äù is an oxymoron üòû so we‚Äôve done our best to keep this book *brief*, *useful* and *approachable*.<sup>1</sup> The code samples are in idiomatic Python, and the explanations assume that you‚Äôre a software engineer, not a prospective computer science researcher.

We‚Äôve also spent more time than usual on some particularly interesting topics like graph traversal and dynamic programming, and less on traditional favorites like sorting algorithms. That‚Äôs because we've found ourselves writing graph traversal algorithms _all the time_ in our own software, but basically never implement quicksort. We still love the algorithms that we‚Äôve excluded; as much as possible we link out to other resources for those whose curiosity tempts them beyond the ‚Äúpractical‚Äù scope of this book.

Finally, we‚Äôd like to mention that this book started as a fork of _Problem Solving with Algorithms and Data Structures Using Python_, generously Creative Commons licensed by its authors Brad Miller and David Ranum. We chose to adapt their book based on our experience teaching algorithms to practicing software engineers at [Bradfield](https://bradfieldcs.com/). Our version is also open source and Creative Commons licensed, and we invite [pull requests](https://github.com/bradfield/algos).

---

<p class="footnote"><sup>[1]</sup>Our best explanation for such skepticism is that those engineers never encountered these topics in a way that encouraged deep understanding. Perhaps they were <a href="http://v.cx/2010/04/feynman-brazil-education">unfortunate enough</a> to participate in a computer science program that encouraged rote memorization, or subjected themselves to such an experience for the sake of succeeding at technical interviews. Or perhaps they became adequate programmers without having encountered the content at all and presume that they‚Äôve reached the limits of their capabilities.</sup></p>
